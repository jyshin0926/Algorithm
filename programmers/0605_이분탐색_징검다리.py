def solution(distance, rocks, n):
    ans = 0
    start, end = 1, distance  # start : 돌이 겹쳐있는 경우는 없으니까 1
    rocks.sort()
    while start <= end:
        mid = start + (end-start)//2
        rm_cnt = 0; st_rock=0  # 제거한 돌 카운팅; 기준 돌
        for rock in rocks:
            if rm_cnt > n:  # 이 조건문은 없어도 되지만, 제거한 돌이 문제 조건보다 크면 break 시켜주는 게 속도 더 빠름
                break
            if rock - st_rock < mid:
                rm_cnt += 1     # mid보다 작으면 늘리기
            else:
                st_rock = rock  # 아니라면, 해당 rock을 새로운 기준으로 세우기
        if rm_cnt > n:
            end = mid-1
        else:
            ans = mid
            start = mid + 1
    return ans

print(solution(25, [2,14,11,21,17], 2))

# for문 안에서 break 문 안 줬을 때
# 통과 (0.26ms, 10.2MB)
# 테스트 2 〉	통과 (0.29ms, 10.3MB)
# 테스트 3 〉	통과 (0.29ms, 10.2MB)
# 테스트 4 〉	통과 (8.16ms, 10.3MB)
# 테스트 5 〉	통과 (7.12ms, 10.4MB)
# 테스트 6 〉	통과 (86.42ms, 12.2MB)
# 테스트 7 〉	통과 (113.80ms, 12.2MB)
# 테스트 8 〉	통과 (114.47ms, 12.2MB)
# 테스트 9 〉	통과 (0.01ms, 10.2MB)

# break문 줬을 때
# 테스트 1 〉	통과 (0.35ms, 10.3MB)
# 테스트 2 〉	통과 (0.46ms, 10.2MB)
# 테스트 3 〉	통과 (0.34ms, 10.3MB)
# 테스트 4 〉	통과 (5.20ms, 10.3MB)
# 테스트 5 〉	통과 (5.25ms, 10.4MB)
# 테스트 6 〉	통과 (21.67ms, 12.2MB)
# 테스트 7 〉	통과 (55.50ms, 12.2MB)
# 테스트 8 〉	통과 (73.22ms, 12.1MB)
# 테스트 9 〉	통과 (0.01ms, 10.3MB)


# 도착지점 25만큼 떨어져있고
# [2,14,11,21,17] 지점에 바위 있음
# n개 돌 징검다리에서 제거했을 때 최소 거리
# 범위 생각해보면 최소값은 징검다리에 돌이 겹쳐있는 경우 없으므로 1
# 최대값 : 시작지점~도착지점 거리 = distance
# 이 값 기준으로 mid가 n개의 돌 제거했을 때 돌 사이의 거리중 최소값으로 가정
# 이 가정하에 돌을 제거했을 때 이 값(mid)보다 작은 거리는 없어야 함
# 돌 사이의 거리를 구했을 때 이 mid 값보다 작으면 제거하고 크면 두는 방식으로

# 돌 사이의 거리를 모두 재는 것은 무의미
# 시작지점(=st_rock=0)으로부터 mid값 보다 먼 거리에 있는 돌을 찾기 전까지 돌을 제거하고 찾으면
# 그 돌을 새로운 기준으로 삼아 다시 돌 사이의 거리를 측정하기
